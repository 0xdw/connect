<!DOCTYPE html><html><head><title>Connect - High quality middleware for node.js</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link rel="stylesheet" href="style.css"><script src="jquery.js"></script><script src="docs.js"></script></head><body><div id="content"><h1>Connect</h1><div id="exports.methods" class="comment"><h2>exports.methods</h2><div class="description"><p>Supported content-encoding methods.</p></div><h3>Source</h3><pre><code>exports.methods = {
    gzip: zlib.createGzip
  , deflate: zlib.createDeflate
};</code></pre></div><div id="exports.filter" class="comment"><h2>exports.filter()</h2><div class="description"><p>Default filter function.</p></div><h3>Source</h3><pre><code>exports.filter = function(req, res){
  return /json|text|javascript/.test(res.getHeader('Content-Type'));
};</code></pre></div><div id="module.exports" class="comment"><h2></h2><div class="description"><h2>Compress</h2>

<p>Compress response data with gzip/deflate.</p>

<h2>Filter</h2>

<p>A <code>filter</code> callback function may be passed to<br /> replace the default logic of:</p>

<pre><code>exports.filter = function(req, res){
  return /json|text|javascript/.test(res.getHeader('Content-Type'));
};
</code></pre>

<h2>Options</h2>

<p>All remaining options are passed to the gzip/deflate<br /> creation functions. Consult node's docs for additional details.</p>

<ul>
<li><code>chunkSize</code> (default: 16*1024)</li>
<li><code>windowBits</code></li>
<li><code>level</code>: 0-9 where 0 is no compression, and 9 is slow but best compression</li>
<li><code>memLevel</code>: 1-9 low is slower but uses less memory, high is fast but uses more</li>
<li><code>strategy</code>: compression strategy</li>
</ul></div><ul class="tags"><li><em>Object</em> options </li><li>returns <em>Function</em> </li></ul><h3>Source</h3><pre><code>module.exports = function compress(options) {
  var options = options || {}
    , names = Object.keys(exports.methods)
    , filter = options.filter || exports.filter;

  return function(req, res, next){
    var accept = req.headers['accept-encoding']
      , write = res.write
      , end = res.end
      , stream
      , method;

    // vary
    res.setHeader('Vary', 'Accept-Encoding');

    // proxy

    res.write = function(chunk, encoding){
      if (!this.headerSent) this._implicitHeader();
      return stream
        ? stream.write(new Buffer(chunk, encoding))
        : write.call(res, chunk, encoding);
    };

    res.end = function(chunk, encoding){
      if (chunk) this.write(chunk, encoding);
      return stream
        ? stream.end()
        : end.call(res);
    };

    res.on('header', function(){
      var encoding = res.getHeader('Content-Encoding') || 'identity';

      // already encoded
      if ('identity' != encoding) return; 

      // default request filter
      if (!filter(req, res)) return;

      // SHOULD use identity
      if (!accept) return;

      // head
      if ('HEAD' == req.method) return;

      // default to gzip
      if ('*' == accept.trim()) method = 'gzip';

      // compression method
      if (!method) {
        for (var i = 0, len = names.length; i < len; ++i) {
          if (~accept.indexOf(names[i])) {
            method = names[i];
            break;
          }
        }
      }

      // compression method
      if (!method) return;

      // compression stream
      stream = exports.methods[method](options);

      // header fields
      res.setHeader('Content-Encoding', method);
      res.removeHeader('Content-Length');

      // compression

      stream.on('data', function(chunk){
        write.call(res, chunk);
      });

      stream.on('end', function(){
        end.call(res);
      });

      stream.on('drain', function() {
        res.emit('drain');
      });
    });

    next();
  };
}</code></pre></div></div><ul id="menu"><li><a href="#exports.methods">exports.methods</a></li><li><a href="#exports.filter">exports.filter()</a></li><li><a href="#module.exports"></a></li></ul></body></html>