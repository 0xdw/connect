<html>
  <head>
    <title>
      
        Connect - router
      
    </title>
    <link rel='stylesheet' href='main.css' />
  </head>
  <body>
    <div id="content">
      
        <h1>router</h1>
        <span class="filename">lib/middleware/router.js</span>
      

      
      
        
        
        
        
        
        
          <div class="comment">
            
            <p class="description"><p>Provides Sinatra and Express-like routing capabilities.</p></p>

            
              <div class="body">
                <h2>Examples</h2>

<pre><code>connect.router(function(app){
  app.get(&#39;/user/:id&#39;, function(req, res, next){
    // populates req.params.id
  });
  app.put(&#39;/user/:id&#39;, function(req, res, next){
    // populates req.params.id
  });
})</code></pre>
              </div>
            

            
              <ul class="tags">
              
                

                

                

                
                  <li class="param"><em>param</em> <span class="types">Function</span> <span class="name">fn</span> <span class="description"></span></li>
                
              
                
                  <li class="return"><em>returns</em> <span class="types">Function</span></li>
                

                

                

                
              
                

                
                  <li class="api"><em>api</em> <span class="visibility">public</span></li>
                

                

                
              
              </ul>

<!--            
              <pre class="code">
                <code>
function router(fn){
  var self = this
    , methods = {}
    , routes = {}
    , params = {};

  if (!fn) throw new Error('router provider requires a callback function');

  // Generate method functions
  _methods.forEach(function(method){
    methods[method] = generateMethodFunction(method.toUpperCase());
  });

  // Alias del -> delete
  methods.del = methods.delete;

  // Apply callback to all methods
  methods.all = function(){
    var args = arguments;
    _methods.forEach(function(name){
      methods[name].apply(this, args);
    });
    return self;
  };

  // Register param callback
  methods.param = function(name, fn){
    params[name] = fn;
  };
      
  fn.call(this, methods);

  function generateMethodFunction(name) {
    var localRoutes = routes[name] = routes[name] || [];
    return function(path, fn){
      var keys = []
        , middleware = [];

      // slice middleware
      if (arguments.length > 2) {
        middleware = Array.prototype.slice.call(arguments, 1, arguments.length);
        fn = middleware.pop();
        middleware = utils.flatten(middleware);
      }

      fn.middleware = middleware;

      if (!path) throw new Error(name + ' route requires a path');
      if (!fn) throw new Error(name + ' route ' + path + ' requires a callback');
      var regexp = path instanceof RegExp
        ? path
        : normalizePath(path, keys);
      localRoutes.push({
          fn: fn
        , path: regexp
        , keys: keys
        , orig: path
        , method: name
      });
      return self;
    };
  }

  function router(req, res, next){
    var route
      , self = this;

    (function pass(i){
      if (route = match(req, routes, i)) {
        var i = 0
          , keys = route.keys;

        req.params = route.params;

        // Param preconditions
        (function param(err) {
          try {
            var key = keys[i++]
              , val = req.params[key]
              , fn = params[key];

            if ('route' == err) {
              pass(req._route_index + 1);
            // Error
            } else if (err) {
              next(err);
            // Param has callback
            } else if (fn) {
              // Return style
              if (1 == fn.length) {
                req.params[key] = fn(val);
                param();
              // Middleware style
              } else {
                fn(req, res, param, val);
              }
            // Finished processing params
            } else if (!key) {
              // route middleware
              i = 0;
              (function nextMiddleware(err){
                var fn = route.middleware[i++];
                if ('route' == err) {
                  pass(req._route_index + 1);
                } else if (err) {
                  next(err);
                } else if (fn) {
                  fn(req, res, nextMiddleware);
                } else {
                  route.call(self, req, res, function(err){
                    if (err) {
                      next(err);
                    } else {
                      pass(req._route_index + 1);
                    }
                  });
                }
              })();
            // More params
            } else {
              param();
            }
          } catch (err) {
            next(err);
          }
        })();
      } else if ('OPTIONS' == req.method) {
        options(req, res, routes);
      } else {
        next();
      }
    })();
  };

  router.remove = function(path, method){
    var fns = router.lookup(path, method);
    fns.forEach(function(fn){
      routes[fn.method].splice(fn.index, 1);
    });
  };

  router.lookup = function(path, method, ret){
    ret = ret || [];

    // method specific lookup
    if (method) {
      method = method.toUpperCase();
      if (routes[method]) {
        routes[method].forEach(function(route, i){
          if (path == route.orig) {
            var fn = route.fn;
            fn.regexp = route.path;
            fn.keys = route.keys;
            fn.path = route.orig;
            fn.method = route.method;
            fn.index = i;
            ret.push(fn);
          }
        });
      }
    // global lookup
    } else {
      _methods.forEach(function(method){
        router.lookup(path, method, ret);
      });
    }

    return ret;
  };

  router.match = function(url, method, ret){
    var ret = ret || []
      , i = 0
      , fn
      , req;

    // method specific matches
    if (method) {
      method = method.toUpperCase();
      req = { url: url, method: method };
      while (fn = match(req, routes, i)) {
        i = req._route_index + 1;
        ret.push(fn);
      } 
    // global matches
    } else {
      _methods.forEach(function(method){
        router.match(url, method, ret);
      });
    }

    return ret;
  };

  return router;
}
                </code>
              </pre>
             -->
          
          </div>
        
      
        
        
        
        
        
      
    </div>
  </body>
</html>