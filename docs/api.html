<h2 id='NAME'>NAME</h2>
<p><code>connect</code> -- node server runner</p>

<h2>Synopsis</h2>

<pre><code>connect [-H|--host ADDR] [-p|--port NUM]
        [-D|--daemonize] [-I|--include PATH]
        [-E|--env NAME] [-e|--eval CODE] [-C|--chdir PATH]
        [-c|--config PATH] [-P|--pidfile PATH]
        [-l|--logfile PATH] [-u|--user ID] [-g|--group ID]
        [-v|--verbose] [-K|--no-color] [-h|--help]
        start|stop|restart [PATH]
</code></pre>

<h2>Description</h2>

<p> <code>Connect</code> is a duel purpose library, aiding in both rapid development,
 and deployment of node servers. Connect "middleware" can be stacked
 to create a robust application within minutes. The <em>connect</em> executable
 supports launching of both regular <code>net.Server</code>, and <code>connect.Server</code> instances.</p>

<p> <em>connect</em> supplies <em>init.d</em> friendly <em>start</em>, <em>stop</em>, and <em>restart</em> commands,
 and accept a direct path to the module meant to be run, otherwise defaults
 to trying both <em>app.js</em> and <em>server.js</em> in the current working directory.</p>

<h2>Executable Options</h2>

<pre><code>-H, --host ADDR      Host address, defaults to INADDR_ANY
-p, --port NUM       Port number, defaults to 3000
-D, --daemonize      Daemonize the server process
-I, --include PATH   Unshift the given path to require.paths
-E, --env NAME       Set environment, defaults to "development"
-e, --eval CODE      Evaluate the given string
-C, --chdir PATH     Change to the given path
-c, --config PATH    Load configuration module
-P, --pidfile PATH   PID file, defaults to pids/connect.pid
-l, --logfile PATH   Log file, defaults to logs/connect.log
-u, --user ID        Change user with setuid()
-g, --group ID       Change group with setgid()
-v, --verbose        Display verbose output
-K, --no-color       Suppress colored terminal output
-h, --help           Display help information
</code></pre>

<h2>Middleware</h2>

<p> Connect middleware is divided into two concepts. First we have <em>filters</em>
 which perform an action and allow lower middleware to respond
 to the request, secondly we have <em>providers</em> which are conceptual "end-points",
 responding to the request without continuing down the stack.</p>

<h2>Middleware Usage</h2>

<p> Below is an example which shows usage of the <em>log</em> filter
 bundled with <code>Connect</code>, as well as the <em>static</em> provider.</p>

<p> The keys <em>filter</em> and <em>provider</em> are used only as short-cuts
 to bundled middleware, to utilize a custom module we can
 assign a module's exports to the <code>module</code> key.</p>

<pre><code>module.exports = require('./lib/connect').createServer([
    { filter: 'log' },
    { module: require('path/to/custom/middleware') },
    { provider: 'static', root: __dirname + '/public' }
]);
</code></pre>

<p> As shown above the module exports a <code>connect.Server</code> and
 does not call the <code>listen()</code> method directly. This allows other
 modules to "mount" this app, as well as allowing the <em>connect</em>
 executable to control how the server is run.</p>

<p> If you prefer not to use <em>connect</em>, you can simply create a script
 executable by <em>node</em>, <code>require()</code> the app, then invoke <code>listen()</code>.</p>

<pre><code>#!/usr/bin/env node
require('./app').listen();
</code></pre>
