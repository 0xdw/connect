<!DOCTYPE html><html><head><title>Connect - High quality middleware for node.js</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link rel="stylesheet" href="style.css"><script src="jquery.js"></script><script src="docs.js"></script></head><body><div id="content"><h1>Connect</h1><div id="" class="comment"><h2></h2><div class="description"><p>Expose the middleware.</p></div><h3>Source</h3><pre><code>exports = module.exports = session;</code></pre></div><div id="exports.Store" class="comment"><h2>exports.Store</h2><div class="description"><p>Expose constructors.</p></div><h3>Source</h3><pre><code>exports.Store = Store;
exports.Cookie = Cookie;
exports.Session = Session;
exports.MemoryStore = MemoryStore;</code></pre></div><div id="warning" class="comment"><h2>warning</h2><div class="description"><p>Warning message for <code>MemoryStore</code> usage in production.</p></div><h3>Source</h3><pre><code>var warning = 'Warning: connection.session() MemoryStore is not\n'
  + 'designed for a production environment, as it will leak\n'
  + 'memory, and obviously only work within a single process.';</code></pre></div><div id="session" class="comment"><h2>session()</h2><div class="description"><h2>Session</h2>

<p>Setup session store with the given <code>options</code>.</p>

<p>Session data is <em>not</em> saved in the cookie itself, however<br />  cookies are used, so we must use the <a href="cookieParser.html">cookieParser()</a><br />  middleware <em>before</em> <code>session()</code>.</p>

<h2>Examples</h2>

<pre><code>connect()
  .use(connect.cookieParser('keyboard cat'))
  .use(connect.session({ key: 'sid', cookie: { secure: true }}))
</code></pre>

<h2>Options</h2>

<ul>
<li><code>key</code> cookie name defaulting to <code>connect.sid</code></li>
<li><code>store</code> session store instance</li>
<li><code>cookie</code> session cookie settings, defaulting to <code>{ path: '/', httpOnly: true, maxAge: null }</code></li>
<li><code>proxy</code> trust the reverse proxy when setting secure cookies (via "x-forwarded-proto")</li>
</ul>

<h2>Cookie option</h2>

<p>By default <code>cookie.maxAge</code> is <code>null</code>, meaning no "expires" parameter is set<br /> so the cookie becomes a browser-session cookie. When the user closes the <br /> browser the cookie (and session) will be removed.</p>

<h2>req.session</h2>

<p>To store or access session data, simply use the request property <code>req.session</code>,<br /> which is (generally) serialized as JSON by the store, so nested objects <br /> are typically fine. For example below is a user-specific view counter:</p>

<pre><code>  connect()
    .use(connect.favicon())
    .use(connect.cookieParser('keyboard cat'))
    .use(connect.session({ cookie: { maxAge: 60000 }}))
    .use(function(req, res, next){
      var sess = req.session;
      if (sess.views) {
        res.setHeader('Content-Type', 'text/html');
        res.write('&lt;p&gt;views: ' + sess.views + '&lt;/p&gt;');
        res.write('&lt;p&gt;expires in: ' + (sess.cookie.maxAge / 1000) + 's&lt;/p&gt;');
        res.end();
        sess.views++;
      } else {
        sess.views = 1;
        res.end('welcome to the session demo. refresh!');
      }
    }
  )).listen(3000);
</code></pre>

<h2>Session#regenerate()</h2>

<p>To regenerate the session simply invoke the method, once complete<br /> a new SID and <code>Session</code> instance will be initialized at <code>req.session</code>.</p>

<pre><code> req.session.regenerate(function(err){
   // will have a new session here
 });
</code></pre>

<h2>Session#destroy()</h2>

<p>Destroys the session, removing <code>req.session</code>, will be re-generated next request.</p>

<pre><code> req.session.destroy(function(err){
   // cannot access session here
 });
</code></pre>

<h2>Session#reload()</h2>

<p>Reloads the session data.</p>

<pre><code> req.session.reload(function(err){
   // session updated
 });
</code></pre>

<h2>Session#save()</h2>

<p>Save the session.</p>

<pre><code> req.session.save(function(err){
   // session saved
 });
</code></pre>

<h2>Session#touch()</h2>

<p>Updates the <code>.maxAge</code>, and <code>.lastAccess</code> properties. Typically this is<br />  not necessary to call, as the session middleware does this for you.</p>

<h2>Session#cookie</h2>

<p>Each session has a unique cookie object accompany it. This allows<br /> you to alter the session cookie per visitor. For example we can<br /> set <code>req.session.cookie.expires</code> to <code>false</code> to enable the cookie<br /> to remain for only the duration of the user-agent.</p>

<h2>Session#maxAge</h2>

<p>Alternatively <code>req.session.cookie.maxAge</code> will return the time<br /> remaining in milliseconds, which we may also re-assign a new value<br /> to adjust the <code>.expires</code> property appropriately. The following<br /> are essentially equivalent</p>

<pre><code>var hour = 3600000;
req.session.cookie.expires = new Date(Date.now() + hour);
req.session.cookie.maxAge = hour;
</code></pre>

<p>For example when <code>maxAge</code> is set to <code>60000</code> (one minute), and 30 seconds<br />has elapsed it will return <code>30000</code> until the current request has completed,<br />at which time <code>req.session.touch()</code> is called to update <code>req.session.lastAccess</code>,<br />and reset <code>req.session.maxAge</code> to its original value.</p>

<pre><code>req.session.cookie.maxAge;
// =&gt; 30000
</code></pre>

<h2>Session Store Implementation</h2>

<p>Every session store <em>must</em> implement the following methods</p>

<ul>
<li><code>.get(sid, callback)</code></li>
<li><code>.set(sid, session, callback)</code></li>
<li><code>.destroy(sid, callback)</code></li>
</ul>

<p>Recommended methods include, but are not limited to:</p>

<ul>
<li><code>.length(callback)</code></li>
<li><code>.clear(callback)</code></li>
</ul>

<p>For an example implementation view the <a href="http://github.com/visionmedia/connect-redis">connect-redis</a> repo.</p></div><ul class="tags"><li><em>Object</em> options </li><li>returns <em>Function</em> </li></ul><h3>Source</h3><pre><code>function session(options){
  var options = options || {}
    , key = options.key || 'connect.sid'
    , store = options.store || new MemoryStore
    , cookie = options.cookie
    , trustProxy = options.proxy;

  // notify user that this store is not
  // meant for a production environment
  if ('production' == env && store instanceof MemoryStore) {
    console.warn(warning);
  }

  // generates the new session
  store.generate = function(req){
    req.sessionID = utils.uid(24);
    req.session = new Session(req);
    req.session.cookie = new Cookie(req, cookie);
  };

  return function session(req, res, next) {
    // self-awareness
    if (req.session) return next();

    // ensure secret is available or bail
    if (!req.secret) throw new Error('connect.cookieParser("secret") required for security when using sessions');

    // parse url
    var url = parse(req.url)
      , path = url.pathname
      , sessionIsNew;

    // expose store
    req.sessionStore = store;

    // set-cookie
    res.on('header', function(){
      if (!req.session) return;
      var cookie = req.session.cookie
        , proto = (req.headers['x-forwarded-proto'] || '').toLowerCase()
        , tls = req.connection.encrypted || (trustProxy && 'https' == proto)
        , secured = cookie.secure && tls;

      // browser-session cookies only set-cookie once
      if (null == cookie.expires && !sessionIsNew) return;

      // only send secure cookies via https
      if (cookie.secure && !secured) return debug('not secured');

      debug('set %s to %s', key, req.sessionID);
      res.setHeader('Set-Cookie', cookie.serialize(key, req.sessionID));
    });

    // proxy end() to commit the session
    var end = res.end;
    res.end = function(data, encoding){
      res.end = end;
      if (!req.session) return res.end(data, encoding);
      debug('saving');
      req.session.resetMaxAge();
      req.session.save(function(){
        debug('saved');
        res.end(data, encoding);
      });
    };

    // generate the session
    function generate() {
      sessionIsNew = true;
      store.generate(req);
    }

    // get the sessionID from the cookie
    req.sessionID = req.signedCookies[key];

    // generate a session if the browser doesn't send a sessionID
    if (!req.sessionID) {
      debug('no SID sent, generating session');
      generate();
      next();
      return;
    }

    // generate the session object
    var pause = utils.pause(req);
    debug('fetching %s', req.sessionID);
    store.get(req.sessionID, function(err, sess){
      // proxy to resume() events
      var _next = next;
      next = function(err){
        _next(err);
        pause.resume();
      }

      // error handling
      if (err) {
        debug('error');
        if ('ENOENT' == err.code) {
          generate();
          next();
        } else {
          next(err);
        }
      // no session
      } else if (!sess) {
        debug('no session found');
        generate();
        next();
      // populate req.session
      } else {
        debug('session found');
        store.createSession(req, sess);
        next();
      }
    });
  };
};</code></pre></div></div><ul id="menu"><li><a href="#"></a></li><li><a href="#exports.Store">exports.Store</a></li><li><a href="#warning">warning</a></li><li><a href="#session">session()</a></li></ul></body></html>