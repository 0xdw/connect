<!DOCTYPE html><html><head><title>Connect - High quality middleware for node.js</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><link rel="stylesheet" href="style.css"><script src="jquery.js"></script><script src="docs.js"></script></head><body><div id="content"><h1>Connect</h1><p>High quality middleware for node.js</p><div id="module.exports" class="comment"><h2></h2><div class="description"><h2>Static cache</h2>

<p>Enables a memory cache layer on top of<br />the <code>static()</code> middleware, serving popular<br />static files.</p>

<p>By default a maximum of 128 objects are<br />held in cache, with a max of 256k each,<br />totalling ~32mb.</p>

<p>A Least-Recently-Used (LRU) cache algo<br />is implemented through the <code>Cache</code> object,<br />simply rotating cache objects as they are<br />hit. This means that increasingly popular<br />objects maintain their positions while<br />others get shoved out of the stack and<br />garbage collected.</p>

<h2>Benchmarks</h2>

<pre><code>static(): 2700 rps
node-static: 5300 rps
static() + staticCache(): 7500 rps
</code></pre>

<h2>Options</h2>

<ul>
<li><code>maxObjects</code>  max cache objects [128]</li>
<li><code>maxLength</code>  max cache object length 256kb</li>
</ul></div><ul class="tags"><li><em>Type</em> name </li><li>returns <em>Type</em> </li></ul><h3>Source</h3><pre><code>module.exports = function staticCache(options){
  var options = options || {}
    , cache = new Cache(options.maxObjects || 128)
    , maxlen = options.maxLength || 1024 * 256;

  return function staticCache(req, res, next){
    var path = url.parse(req.url).pathname
      , ranges = req.headers.range
      , hit = cache.get(path)
      , hitCC
      , uaCC
      , header
      , age;

    function miss() {
      res.setHeader('X-Cache', 'MISS');
      next();
    }

    // cache static
    // TODO: change from staticCache() -> static()
    // and make this work for any request
    req.on('static', function(stream){
      var headers = res._headers
        , cc = utils.parseCacheControl(headers['cache-control'] || '')
        , contentLength = headers['content-length']
        , hit;

      // ignore larger files
      if (!contentLength || contentLength > maxlen) return;

      // dont cache items we shouldn't be
      // TODO: real support for must-revalidate / no-cache
      if ( cc['no-cache']
        || cc['no-store']
        || cc['private']
        || cc['must-revalidate']) return;

      // if already in cache then validate
      if (hit = cache.get(path)){
        if (headers.etag == hit[0].etag) {
          hit[0].date = new Date;
          return;
        } else {
          cache.remove(path);
        }
      }

      // validation notifiactions don't contain a steam
      if (null == stream) return;

      // add the cache object
      var arr = cache.add(path);
      arr.push(headers);

      // store the chunks
      stream.on('data', function(chunk){
        arr.push(chunk);
      });

      // flag it as complete
      stream.on('end', function(){
        arr.complete = true;
      });
    });

    // cache hit, doesnt support range requests
    if (hit && hit.complete && !ranges) {
      header = utils.merge({}, hit[0]);
      header.Age = age = (new Date - new Date(header.date)) / 1000 | 0;
      header.date = new Date().toUTCString();

      // parse cache-controls
      hitCC = utils.parseCacheControl(header['cache-control'] || '');
      uaCC = utils.parseCacheControl(req.headers['cache-control'] || '');

      // check if we must revalidate(bypass)
      if (hitCC['no-cache'] || uaCC['no-cache']) return miss();

      // check freshness of entity
      if (isStale(hitCC, age) || isStale(uaCC, age)) return miss();

      // conditional GET support
      if (utils.conditionalGET(req)) {
        if (!utils.modified(req, res, header)) {
          header['content-length'] = 0;
          res.writeHead(304, header);
          return res.end();
        }
      }

      // HEAD support
      if ('HEAD' == req.method) {
        res.writeHead(200, header);
        return res.end();
      }

      // respond with cache
      header['x-cache'] = 'HIT';
      res.writeHead(200, header);

      // backpressure
      function write(i) {
        var buf = hit[i];
        if (!buf) return res.end();
        if (false === res.write(buf)) {
          res.once('drain', function(){
            write(++i);
          });
        } else {
          write(++i);
        }
      }

      return write(1);
    }

    miss();
  }
};</code></pre></div><div id="isStale" class="comment"><h2>isStale()</h2><div class="description"><p>Check if cache item is stale</p></div><ul class="tags"><li><em>Object</em> cc </li><li><em>Number</em> age </li><li>returns <em>Boolean</em> </li></ul><h3>Source</h3><pre><code>function isStale(cc, age) {
  return cc['max-age'] && cc['max-age'] <= age;
}</code></pre></div></div><ul id="menu"><li><a href="#module.exports"></a></li><li><a href="#isStale">isStale()</a></li></ul></body></html>